#ifndef MIX_DD_MORE_ALGORITHM_HPP
#define MIX_DD_MORE_ALGORITHM_HPP

#include "../utils/more_vector.hpp"

#include <algorithm>
#include <iterator>
#include <type_traits>
#include <utility>
#include <limits>

namespace mix::utils
{
    namespace impl
    {
        template<class InputIt, class UnaryOperation>
        auto map(InputIt first, InputIt last, std::size_t const count, UnaryOperation op)
        {
            using T = decltype(op(*first));
            auto result = utils::vector<T>(count);
            std::transform(first, last, std::back_inserter(result), op);
            return result;
        }

        template<class InputIt, class Predicate, class UnaryOperation>
        auto map_if(InputIt first, InputIt last, std::size_t const count, Predicate p, UnaryOperation op)
        {
            using T = decltype(op(*first));
            auto result = utils::vector<T>(count);
            while (first != last)
            {
                if (p(*first))
                {
                    result.push_back(op(*first));
                }
                ++first;
            }
            return result;
        }
    }

    /**
        @brief Wrap around std::transform that saves the result into a std::vector.
     */
    template<class InputIt, class UnaryOperation>
    auto map(InputIt first, InputIt last, UnaryOperation op)
    {
        using input_it_category = typename std::iterator_traits<InputIt>::iterator_category;
        auto constexpr hasFastCount = std::is_same_v< input_it_category
                                                    , std::random_access_iterator_tag >;
        if constexpr (hasFastCount)
        {
            return impl::map(first, last, static_cast<std::size_t>(std::distance(first, last)), op);
        }
        else
        {
            return impl::map(first, last, 4ul, op);
        }
    }

    /**
        @brief Wrap around std::transform that saves the result into a std::vector.
     */
    template<class Range, class UnaryOperation>
    auto map(Range&& range, UnaryOperation op)
    {
        return map(std::begin(range), std::end(range), op);
    }

    /**
        @brief Wrap around std::transform that saves the result into a std::vector.
     */
    template<class Range, class UnaryOperation>
    auto map(Range&& range, std::size_t const count, UnaryOperation op)
    {
        return impl::map(std::begin(range), std::end(range), count, op);
    }

    /**
        @brief like map but uses predicate to determine whether element should be mapped.
     */
    template<class InputIt, class Predicate, class UnaryOperation>
    auto map_if(InputIt first, InputIt last, Predicate p, UnaryOperation op)
    {
        using input_it_category = typename std::iterator_traits<InputIt>::iterator_category;
        auto constexpr hasFastCount = std::is_same_v< input_it_category
                                                    , std::random_access_iterator_tag >;
        if constexpr (hasFastCount)
        {
            return impl::map_if(first, last, static_cast<std::size_t>(std::distance(first, last)), p, op);
        }
        else
        {
            return impl::map_if(first, last, 4ul, p, op);
        }
    }

    /**
        @brief like map but uses predicate to determine whether element should be mapped.
     */
    template<class Range, class Predicate, class UnaryOperation>
    auto map_if(Range&& range, Predicate p, UnaryOperation op)
    {
        return map_if(std::begin(range), std::end(range), p, op);
    }

    /**
        @brief Wrap around std::transform that saves the result into a std::array.
     */
    template<std::size_t N, class InputIt, class UnaryOperation>
    auto map_to_array(InputIt first, InputIt last, UnaryOperation op)
    {
        using T = decltype(op(*std::declval<InputIt>()));
        auto ret = std::array<T, N>{};
        std::transform(first, last, std::begin(ret), op);
        return ret;
    }

    /**
        @brief Wrap around std::transform that saves the result into a std::array.
     */
    template<class T, std::size_t N, class UnaryOperation>
    auto map_to_array(std::array<T, N> const& as, UnaryOperation op)
    {
        return map_to_array<N>(std::begin(as), std::end(as), op);
    }

    /**
        @brief Wrap around std::transform that saves the result into a std::array.
     */
    template<std::size_t N, class Range, class UnaryOperation>
    auto map_to_array(Range&& range, UnaryOperation op)
    {
        return map_to_array<N>(std::begin(range), std::end(range), op);
    }

    /**
        @brief Fills an array with values generated from a generating function @p f .
        @param f function that has one parameter of an integral type (index).
        @return std::array<decltype(f(0u)), N> of elements generated by @p f .
     */
    template<std::size_t N, class Generator>
    auto constexpr fill_array(Generator&& f)
    {
        using T = decltype(f(0u));
        auto ret = std::array<T, N> {};
        std::generate(std::begin(ret), std::end(ret), [i = 0u, &f]() mutable
        {
            return f(i++);
        });
        return ret;
    }

    /**
        @brief Fills a vector with values generated from a generating function @p f .
        @param n size of the vector.
        @param f function that has one parameter of an integral type (index).
        @return std::vector<decltype(f(0u))> of elements generated by @p f .
     */
    template<class Generator>
    auto fill_vector(std::size_t const n, Generator&& f)
    {
        using T = decltype(f(0u));
        auto ret = utils::vector<T>(n);
        for (auto i = 0u; i < n; ++i)
        {
            ret.emplace_back(f(i));
        }
        return ret;
    }

    /**
        @brief Finds index of @p t in given range. If there is no such elemnt returns max std::size_t.
     */
    template<class InputIt, class T>
    auto index_of (InputIt first, InputIt last, T const& t) -> std::size_t
    {
        auto constexpr npos = std::numeric_limits<std::size_t>::max();
        auto pos = std::find(first, last, t);
        return pos != last ? static_cast<std::size_t>(std::distance(first, pos))
                           : npos;
    }
}

#endif